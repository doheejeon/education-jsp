<%@ page language='java' contentType='text/html; charset=utf-8' pageEncoding='utf-8' %>
<%@ taglib prefix='c' uri='http://java.sun.com/jsp/jstl/core' %> 
<%
	pageContext.setAttribute("one", "페이지"); 
	request.setAttribute("two", "리퀘스트"); 
	session.setAttribute("three", "세션"); 
	application.setAttribute("four", "애플리케이션"); 
%>
<c:redirect url='01.scopeB.jsp'/>
            
<!-- 
◆데이터의 scope을 결정하는 내장객체를 배운다. 4개 (4-7번줄) 4가지 내장객체를 집어넣는 것이 어트리뷰터
	어트리뷰트를 어느 내장객체에 넣느냐 = 내가 내장객체의 스콥을 정하는 방법
	내장객체에 집어넣은 객체를 어트리뷰트가 불러준다.("어트리뷰트네임", 밸류) 첫파라미터 string타입, 두번재파라미터 object
	
4>여기서는 one이라는 attribute의 스콥을 얘기한다.
	각 attribute scope은 (옆의)내장객체의 스콥과 운명을 같이한다.  
	즉 one이 살아있으면 pageContext도 살아남는다. (현재 페이지의 컨테스트, 즉 현재페이지의 환경정보)클라이언트가 서버로 보낸정보들이있음
	"pageContext" 현재 실행되는 페이지의 정보를 갖고있는 객체다. scope은 현재 페이지가 실행되는 동안으로  가장 짧음(다른페이지 이동시 스콥끝남)

5>two의 scope은 request와 함께.. 
	"request" 클라이언트가 서버에 보내는 정보를 갖고있는 객체다. scope: 클라이언트에서리퀘스트가 보내지고 response를 client에게 보낼때까지, (클라이언트가 리퀘스트보낼때 스콥시작, 리스판스보낼떄종료)

6>three는 sesscion과..
	"session" 클라이언트와 서버와의 연결정보를 갖고있는 객체다. scope: 연결이 클라이언트와 서버가 유지되는 동안(최초의 커넥션=최초 리퀘스트가 시작할떄스콥시작)
		세션을(스콥)죽이는것은 알고리즘구현 (로그아웃리퀘스트가 들어오면)혹은 톰캣설정(WAS에 시간설정)
	 ex. 한석이가 네이버에 세션을 보내면, 그 연결을 표현하는 객체(세션객체)가 생긴다. 
	"connectionless" 커넥션부터 연결하고 작업끝날때까지 유지하는것이 그동안  해왔던 방식이였으나 ,http 통신프로토콜에서는 커넥션을 유지하지않는다 .
		→ 리퀘스트를 보낼때마다 커넥션을 연결... 매번 연결을 맺고끊고 반복함 = 
		http에서 커넥션리스하는이유:웹앱은 다수의 사용자가 동시에 사용한다를 전제로하기때문이다. (2만명같이네이버쓰면 네이버힘들)
			물리적인 연결이 수백개여도.. 논리적인 연결은 1개임 
	*디도스 : 빠른속도로 리퀘스트를 계속 보내서, 찾아보셈 
	
7>four는 application과 ..
	"application" scope: 앱이 실행되는 동안(톰캣이 실행돼서 종료될때까지)

 ∴ 4개의 내장객체중, 스콥이 가장 긴 것은 애플리케이션이다. 
 
 A forward B 라면 페이지 컨테스트는 3개가된다. 페이지 컨테스트는 스콥이 워낙 짧아서 쓸모가 없다. 
 결국 리퀘스트안에 어트리뷰트를 가장 많이 넣는다. 이유: 작업의 시콥이 리퀘스트 스콥이라서 (사람의 생각이 그렇게 생겨먹어서 직선적이라서)
 -->